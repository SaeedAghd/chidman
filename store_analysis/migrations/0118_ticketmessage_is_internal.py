# Generated by Django 4.2.23 on 2025-11-02 21:54
# Modified to safely handle existing column

from django.db import migrations, models


def add_is_internal_if_missing(apps, schema_editor):
    """
    Safely add is_internal field to TicketMessage if it doesn't exist
    Works with both PostgreSQL (Liara) and SQLite (local dev)
    """
    db_alias = schema_editor.connection.alias
    vendor = schema_editor.connection.vendor
    
    column_exists = False
    
    # Check if column exists based on database vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == 'postgresql':
            # PostgreSQL uses information_schema
            cursor.execute("""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name='store_analysis_ticketmessage' 
                AND column_name='is_internal'
            """)
            column_exists = cursor.fetchone() is not None
        elif vendor == 'sqlite':
            # SQLite uses PRAGMA table_info
            cursor.execute("PRAGMA table_info(store_analysis_ticketmessage)")
            columns = [row[1] for row in cursor.fetchall()]
            column_exists = 'is_internal' in columns
    
    # Add is_internal if it doesn't exist
    if not column_exists:
        print("üìä Adding is_internal field to TicketMessage...")
        with schema_editor.connection.cursor() as cursor:
            if vendor == 'postgresql':
                cursor.execute("""
                    ALTER TABLE store_analysis_ticketmessage 
                    ADD COLUMN is_internal BOOLEAN DEFAULT FALSE;
                """)
            elif vendor == 'sqlite':
                cursor.execute("""
                    ALTER TABLE store_analysis_ticketmessage 
                    ADD COLUMN is_internal BOOLEAN DEFAULT 0;
                """)
        print("‚úÖ is_internal field added")
    else:
        print("‚ÑπÔ∏è is_internal field already exists, skipping...")


def remove_is_internal_safe(apps, schema_editor):
    """
    Reverse migration - remove is_internal field if needed
    """
    db_alias = schema_editor.connection.alias
    vendor = schema_editor.connection.vendor
    
    column_exists = False
    
    # Check if column exists based on database vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == 'postgresql':
            cursor.execute("""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name='store_analysis_ticketmessage' 
                AND column_name='is_internal'
            """)
            column_exists = cursor.fetchone() is not None
        elif vendor == 'sqlite':
            cursor.execute("PRAGMA table_info(store_analysis_ticketmessage)")
            columns = [row[1] for row in cursor.fetchall()]
            column_exists = 'is_internal' in columns
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == 'postgresql':
            if column_exists:
                cursor.execute(
                    "ALTER TABLE store_analysis_ticketmessage DROP COLUMN IF EXISTS is_internal;"
                )
        elif vendor == 'sqlite':
            # SQLite doesn't support DROP COLUMN easily, skip for now
            pass


class Migration(migrations.Migration):

    dependencies = [
        ('store_analysis', '0117_fix_userprofile_address_safe'),
    ]

    operations = [
        migrations.RunPython(add_is_internal_if_missing, remove_is_internal_safe),
    ]
